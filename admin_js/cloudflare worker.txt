/**
 * Cloudflare Worker: Proxy to Google Apps Script (Code.gs)
 *
 * New / Updated backend actions supported:
 *  - GET  ?action=me&idToken=...
 *  - GET  ?action=getBalance&idToken=...&userId=...
 *  - GET  ?action=myOpenOrders&idToken=...
 *  - GET  ?action=listings&q=...
 *  - GET  ?action=listMyListings&idToken=...
 *  - GET  ?action=listTrades&idToken=...&status=PENDING|EXECUTED|...
 *  - POST {action:"linkPlayer", idToken, payload:{playerName, mailbox}, recaptchaToken?}
 *  - POST {action:"createRequest", idToken, payload:{...}, onBehalfOf?, recaptchaToken?}
 *  - POST {action:"requestAccountClaim", idToken, payload:{targetRef}}
 *  - POST {action:"createListing", idToken, type, itemName, price, priceUnit, quantity, stackSize?, sourceItemId?, status?, recaptchaToken?}
 *  - POST {action:"updateListing", idToken, listingId, price?, priceUnit?, quantity?, status?, stackSize?, sourceItemId?}
 *  - POST {action:"toggleListingStatus", idToken, listingId, status:true|false}
 *  - POST {action:"deleteListing", idToken, listingId}
 *  - POST {action:"createTradeRequest", idToken, listingId, quantity}
 *  - POST {action:"approveTrade", idToken, tradeId}
 *  - POST {action:"denyTrade", idToken, tradeId}
 *  - POST {action:"transferBT", idToken, targetPlayerName|targetUserId, amountBT, note?}
 *  - POST {action:"adjustBalance", idToken, userId, deltaBT, reason}
 */
const GAS_BASE_FALLBACK = 'https://script.google.com/macros/s/AKfycbzAmduSpdIAkcEDhQD8b-uf6OSkQpII7VfSRUPcYK5z4dMXpM5E0aZiE5cvTwG-WJ_5Rg/exec';
const UPSTREAM_TIMEOUT_MS = 20000;

export default {
  async fetch(request, env, ctx) {
    const requestId = genRequestId();
    try {
      if (request.method === 'OPTIONS') {
        return respond('', 204, cors({'Access-Control-Max-Age': '86400'}, requestId));
      }
      if (request.method !== 'GET' && request.method !== 'POST') {
        return jsonErr('Method not allowed', 405, null, requestId);
      }
      const url = new URL(request.url);
      const action = url.searchParams.get('action') || '';

      if (!action && (url.pathname === '/' || url.pathname.toLowerCase() === '/exec')) {
        return jsonOk({ service:'vak-gas-proxy', ok:true, at:new Date().toISOString() }, 200, requestId);
      }

      let bodyObj = null;
      if (request.method === 'POST') bodyObj = await tryJson(request);

      // Optional reCAPTCHA pass-through (backend decides enforcement)
      if (env.RECAPTCHA_SECRET && bodyObj?.recaptchaToken) {
        const pass = await verifyRecaptcha(env.RECAPTCHA_SECRET, bodyObj.recaptchaToken, request);
        if (!pass) return jsonErr('reCAPTCHA verification failed', 400, null, requestId);
      }

      const gasResp = await forwardToGas(url, request.method, bodyObj, env);
      const gasText = await gasResp.text();
      let json = null;
      try { json = JSON.parse(gasText); }
      catch {
        return jsonErr('Backend returned non-JSON response', gasResp.status || 502, { raw: gasText.slice(0,1024) }, requestId);
      }
      if (json && json.ok === true && json.data !== undefined && json.result === undefined) {
        json.result = json.data;
      }
      return respond(JSON.stringify(json), gasResp.status, {
        'Content-Type':'application/json',
        ...cors({}, requestId)
      });
    } catch (err) {
      return jsonErr(err?.message || 'Unhandled error', 500, null, requestId);
    }
  }
};

function cors(extra = {}, requestId) {
  return {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Expose-Headers': 'X-Request-Id',
    'Vary': 'Origin',
    'X-Request-Id': requestId || genRequestId(),
    ...extra
  };
}
function respond(body, status=200, headers={}) { return new Response(body, {status, headers}); }
function json(body, status=200, headers={}) {
  const base = {'Content-Type':'application/json'};
  return respond(JSON.stringify(body), status, { ...base, ...headers });
}
function jsonOk(data, status=200, requestId) { return json({ ok:true, data }, status, cors({}, requestId)); }
function jsonErr(error, status=400, extra=undefined, requestId) {
  const payload = extra ? { ok:false, error, extra } : { ok:false, error };
  return json(payload, status, cors({}, requestId));
}
async function tryJson(req) { try { return await req.json(); } catch { return null; } }

function ensureExecSuffix(base) {
  if (!base) return base;
  if (/\/exec(?:\?|$)/i.test(base)) return base;
  return base.replace(/\/+$/, '') + '/exec';
}
function gasBase(env) {
  const base = ensureExecSuffix((env && env.GAS_BASE) || GAS_BASE_FALLBACK);
  if (!base || base.includes('PASTE_YOUR_APPS_SCRIPT_WEB_APP_URL_HERE'))
    throw new Error('GAS_BASE not configured');
  if (!/^https?:\/\//i.test(base))
    throw new Error('GAS_BASE must be absolute URL');
  return base;
}
async function forwardToGas(incomingUrl, method, bodyObj, env) {
  const base = gasBase(env);
  const targetUrl = new URL(base);
  for (const [k,v] of incomingUrl.searchParams.entries()) targetUrl.searchParams.set(k,v);
  const headers = {
    'Content-Type':'application/json',
    'User-Agent':'vak-gas-proxy/1.2 (+cloudflare-workers)'
  };
  const init = { method, headers };
  if (method === 'POST') init.body = JSON.stringify(bodyObj || {});
  const ac = new AbortController();
  const to = setTimeout(()=>ac.abort('upstream-timeout'), UPSTREAM_TIMEOUT_MS);
  try { return await fetch(targetUrl.toString(), { ...init, signal: ac.signal }); }
  finally { clearTimeout(to); }
}

async function verifyRecaptcha(secret, token, request) {
  try {
    const form = new URLSearchParams();
    form.set('secret', secret);
    form.set('response', token);
    const ip = request.headers.get('CF-Connecting-IP');
    if (ip) form.set('remoteip', ip);
    const resp = await fetch('https://www.google.com/recaptcha/api/siteverify', { method:'POST', body:form });
    const j = await resp.json();
    return !!j.success;
  } catch { return false; }
}
function genRequestId() {
  const a = new Uint32Array(4); crypto.getRandomValues(a);
  return [...a].map(x=>x.toString(16).padStart(8,'0')).join('-');
}