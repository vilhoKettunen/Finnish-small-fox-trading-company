<!DOCTYPE html>
<html lang="en">
<head>
    <script src="auth-storage.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Item Market Tracker</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script src="app-config.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="topbar.js"></script>

    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            padding: 1rem;
            background: #fafafa;
            color: #333;
        }

        h1 {
            margin-bottom: 1rem;
            color: #222;
        }

        /* --- CONTROLS BAR --- */
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            background: #fff;
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 1.5rem;
        }

        label {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            font-weight: 500;
            font-size: 0.85rem;
            color: #666;
        }

        select, input[list] {
            padding: .5rem .7rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
            outline: none;
        }

            select:focus, input:focus {
                border-color: #007bff;
            }

        /* Image styling */
        #itemImage {
            height: 90px;
            width: 90px;
            object-fit: contain;
            border-radius: 8px;
            background: #fff;
            margin-left: auto; /* Pushes image to the far right */
            border: 1px solid #eee;
        }

        /* --- CHART CONTAINERS --- */
        #charts {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .chart-title {
            font-weight: 700;
            color: #444;
            font-size: 1.1rem;
        }

        .chart-meta {
            font-size: 0.85rem;
            color: #888;
        }

        /* --- THE FIX FOR INFINITE HEIGHT --- */
        /* We wrap the canvas in a div with relative position and FIXED height */
        .chart-wrapper {
            position: relative;
            height: 400px; /* Strict height limit */
            width: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <h1>Item Market History</h1>

    <div id="controls">
        <label>
            Sheet (Buy/Sell):
            <select id="typeSelect">
                <option value="SellHistory" selected>Buy Prices (SellHistory)</option>
                <option value="BuyHistory">Sell Prices (BuyHistory)</option>
            </select>
        </label>

        <label style="flex-grow: 1; max-width: 300px;">
            Select Item:
            <input id="itemInput" list="itemDatalist" placeholder="Search items..." />
            <datalist id="itemDatalist"></datalist>
        </label>

        <label>
            Time Range:
            <select id="rangeSelect">
                <option value="7">Last 7 days</option>
                <option value="30">Last 30 days</option>
                <option value="180">Last 6 months</option>
                <option value="365">Last year</option>
                <option value="all" selected>All history</option>
            </select>
        </label>

        <label>
            Bottom Chart Metric:
            <select id="metricSelect">
                <option value="stock" selected>Stock Amount</option>
                <option value="change">Daily Price Change (+/-)</option>
                <option value="valuation">Total Valuation</option>
                <option value="goal">Goal Stock %</option>
            </select>
        </label>

        <img id="itemImage" src="" alt="" onerror="this.style.display='none'" />
    </div>

    <div id="charts">
        <div class="chart-card">
            <div class="chart-header">
                <div class="chart-title">Price Trend</div>
                <div class="chart-meta">History of recorded prices</div>
            </div>
            <div class="chart-wrapper">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="chart-card">
            <div class="chart-header">
                <div class="chart-title" id="bottomChartTitle">Stock History</div>
                <div class="chart-meta" id="bottomChartDesc">Amount available</div>
            </div>
            <div class="chart-wrapper">
                <canvas id="secondaryChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // 1. CONFIG
        const USER_LOCALE = (navigator.languages && navigator.languages[0]) || 'en-GB'; // defaulting to UK (Day/Month)
        const SPREADSHEET_ID = "1_meliJtuKSDwEWRDh1gldcsD-pSjDgIND3dcE1mCjCo";

        // 2. HELPERS
        function csvUrl(sheet) {
            return `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheet)}`;
        }

        // --- INTELLIGENT NUMBER PARSER (Handles 1.000,00 vs 1,000.00) ---
        function parseLocalNum(str) {
            if (!str) return null;
            let clean = str.toString().trim().replace(/[^\d.,\-]/g, '');
            if (!clean) return null;

            // Detect format: If comma comes AFTER dot (1.000,50) -> European
            if (clean.indexOf(',') > -1 && clean.indexOf('.') > -1) {
                const lastComma = clean.lastIndexOf(',');
                const lastDot = clean.lastIndexOf('.');
                if (lastComma > lastDot) {
                    clean = clean.replace(/\./g, '').replace(',', '.'); // 1.000,50 -> 1000.50
                } else {
                    clean = clean.replace(/,/g, ''); // 1,000.50 -> 1000.50
                }
            }
            // If ONLY comma (10,5) -> Swap to dot
            else if (clean.indexOf(',') > -1) {
                clean = clean.replace(',', '.');
            }
            // If ONLY dot (10.5) -> keep as is

            const result = parseFloat(clean);
            return isNaN(result) ? null : result;
        }

        // --- STRICT DATE PARSER (Forces Day/Month/Year) ---
        function parseDateStrict(str) {
            if (!str) return null;
            const s = str.trim();

            // Check for standard separators: / or . or -
            const parts = s.split(/[\/\-\.]/);

            // If we have 3 parts (Day, Month, Year)
            if (parts.length === 3) {
                const day = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                let year = parseInt(parts[2], 10);

                // Handle 2-digit years (e.g., 24 -> 2024)
                if (year < 100) year += 2000;

                // JS Months are 0-indexed (0=Jan, 1=Feb)
                return new Date(year, month - 1, day);
            }

            // Fallback: If it's a full ISO string (2024-05-02T...), try standard parse
            const fallback = new Date(s);
            return isNaN(fallback.getTime()) ? null : fallback;
        }

        // 3. FETCH DATA
        let CACHE = { main: [], valuation: [], goal: [] };

        async function fetchCSV(sheetName) {
            try {
                const res = await fetch(csvUrl(sheetName));
                if (!res.ok) throw new Error("Fetch failed");
                const text = await res.text();
                const lines = text.replace(/\r/g, '').split('\n').filter(l => l.trim() !== '');
                if (lines.length <= 1) return [];

                return lines.slice(1).map(line => {
                    // Regex handles quoted CSV fields
                    const parts = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(s => s.replace(/^"|"$/g, '').trim());

                    const dateStr = parts[0];
                    const item = parts[1];

                    // PARSE VALUES
                    const valCol = parseLocalNum(parts[2]);
                    const stockCol = parseLocalNum(parts[3]);

                    // PARSE DATE (STRICTLY DD/MM/YYYY)
                    const ts = parseDateStrict(dateStr);

                    if (sheetName.includes("Valuation") || sheetName.includes("Goal")) {
                        return { ts, item, value: valCol };
                    } else {
                        return { ts, item, value: valCol, stock: stockCol };
                    }
                }).filter(r => r.item && r.ts); // Only keep rows with valid Item AND Date
            } catch (e) {
                console.error("Error loading sheet:", sheetName, e);
                return [];
            }
        }

        // 4. DATA PROCESSING
        function processData(item, rangeDays, metric) {
            const now = new Date();
            const cutoff = rangeDays === 'all' ? new Date(0) : new Date(now - rangeDays * 24 * 60 * 60 * 1000);

            const filterSort = (dataset) => {
                return dataset
                    .filter(r => r.item === item && r.ts && r.ts >= cutoff)
                    .sort((a, b) => a.ts - b.ts);
            };

            const mainData = filterSort(CACHE.main);

            // Top Chart
            const labels = mainData.map(r => r.ts);
            const prices = mainData.map(r => r.value);

            // Bottom Chart
            let secLabels = labels;
            let secValues = [];
            let chartType = 'line';
            let color = '#28a745';

            if (metric === 'stock') {
                secValues = mainData.map(r => r.stock);
            }
            else if (metric === 'change') {
                chartType = 'bar';
                secValues = prices.map((price, i) => {
                    if (i === 0) return 0;
                    return parseFloat((price - prices[i - 1]).toFixed(2));
                });
            }
            else if (metric === 'valuation') {
                const valData = filterSort(CACHE.valuation);
                secLabels = valData.map(r => r.ts);
                secValues = valData.map(r => r.value);
                color = '#6f42c1';
            }
            else if (metric === 'goal') {
                const goalData = filterSort(CACHE.goal);
                secLabels = goalData.map(r => r.ts);
                secValues = goalData.map(r => r.value * 100);
                color = '#fd7e14';
            }

            return { labels, prices, secLabels, secValues, chartType, color };
        }

        // 5. DRAWING
        let priceChartInstance = null;
        let secChartInstance = null;

        function drawCharts(data, metric) {
            const ctx1 = document.getElementById('priceChart').getContext('2d');
            const ctx2 = document.getElementById('secondaryChart').getContext('2d');

            // Format for display (Day Mon)
            const dateFmt = (d) => d ? d.toLocaleDateString(USER_LOCALE, { day: 'numeric', month: 'short' }) : '';

            // CHART 1
            if (priceChartInstance) priceChartInstance.destroy();
            priceChartInstance = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: data.labels.map(dateFmt),
                    datasets: [{
                        label: 'Price',
                        data: data.prices,
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0,123,255,0.1)',
                        borderWidth: 2,
                        tension: 0.2,
                        fill: true,
                        pointRadius: 4,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false }, tooltip: { intersect: false, mode: 'index' } },
                    interaction: { mode: 'nearest', axis: 'x', intersect: false },
                    scales: { y: { beginAtZero: false } }
                }
            });

            // CHART 2
            let bgColors = data.color;
            let borderColors = data.color;

            if (metric === 'change') {
                bgColors = data.secValues.map(v => v >= 0 ? 'rgba(40, 167, 69, 0.6)' : 'rgba(220, 53, 69, 0.6)');
                borderColors = data.secValues.map(v => v >= 0 ? '#28a745' : '#dc3545');
            } else if (data.chartType === 'line') {
                bgColors = data.color + '20';
            }

            if (secChartInstance) secChartInstance.destroy();
            secChartInstance = new Chart(ctx2, {
                type: data.chartType,
                data: {
                    labels: data.secLabels.map(dateFmt),
                    datasets: [{
                        label: 'Value',
                        data: data.secValues,
                        borderColor: borderColors,
                        backgroundColor: bgColors,
                        borderWidth: 1,
                        tension: 0.2,
                        fill: (data.chartType === 'line'),
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            intersect: false,
                            mode: 'index',
                            callbacks: {
                                label: function (ctx) {
                                    let v = ctx.parsed.y;
                                    if (metric === 'change') return (v > 0 ? '+' : '') + v;
                                    if (metric === 'goal') return v.toFixed(1) + '%';
                                    if (metric === 'valuation') return Math.round(v).toLocaleString();
                                    return v;
                                }
                            }
                        }
                    },
                    scales: { y: { beginAtZero: (metric !== 'valuation') } }
                }
            });
        }

        // 6. INIT
        let uniqueItems = [];

        async function init() {
            const typeSel = document.getElementById("typeSelect");
            const itemInput = document.getElementById("itemInput");
            const rangeSel = document.getElementById("rangeSelect");
            const metricSel = document.getElementById("metricSelect");
            const dl = document.getElementById("itemDatalist");

            async function loadData() {
                const sheet = typeSel.value;
                const [main, val, goal] = await Promise.all([
                    fetchCSV(sheet),
                    fetchCSV('ValuationHistory'),
                    fetchCSV('GoalHistory')
                ]);
                CACHE.main = main;
                CACHE.valuation = val;
                CACHE.goal = goal;

                uniqueItems = [...new Set(main.map(r => r.item))].sort();
                dl.innerHTML = "";
                uniqueItems.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = item;
                    dl.appendChild(opt);
                });
            }

            function update() {
                const item = itemInput.value;
                const range = rangeSel.value;
                const metric = metricSel.value;
                const img = document.getElementById("itemImage");

                if (item) {
                    img.style.display = 'block';
                    img.src = `images/${item}.png`;
                } else {
                    img.style.display = 'none';
                }

                const titles = {
                    'stock': 'Stock History',
                    'change': 'Daily Price Volatility',
                    'valuation': 'Total Asset Valuation',
                    'goal': '% of Goal Reached'
                };
                document.getElementById('bottomChartTitle').textContent = titles[metric];

                if (!item || !uniqueItems.includes(item)) return;

                const processed = processData(item, range, metric);
                drawCharts(processed, metric);
            }

            typeSel.addEventListener('change', async () => { await loadData(); update(); });
            itemInput.addEventListener('change', update);
            itemInput.addEventListener('input', update);
            rangeSel.addEventListener('change', update);
            metricSel.addEventListener('change', update);

            await loadData();
            if (uniqueItems.length > 0) {
                itemInput.value = uniqueItems[0];
                update();
            }
        }

         window.onload = () => {
  window.initSharedTopBar && window.initSharedTopBar();
   init();
  };
  
     </script>
</body>
</html>