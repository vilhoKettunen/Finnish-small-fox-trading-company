vintage story\Finnish-small-fox-trading-company\PriceHistory.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Item Buy/Sell History</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: system-ui, sans-serif;
            padding: 1rem;
            background: #fafafa;
        }

        h1 {
            margin-bottom: 1rem;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        select, input[list] {
            padding: .4rem .6rem;
        }

        #itemImage {
            height: 120px;
            border-radius: 12px;
            box-shadow: 0 0 4px rgba(0,0,0,.2);
        }

        canvas {
            max-width: 100%;
            margin-top: 1rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 0 6px rgba(0,0,0,.1);
        }
    </style>
</head>

<body>
    <h1>Item Buy/Sell Price History</h1>

    <div id="controls">
        <label>
            Type:
            <select id="typeSelect">
                <!-- swapped values so selecting the visible label maps to the correct sheet -->
                <option value="SellHistory" selected>Buy</option>
                <option value="BuyHistory">Sell</option>
            </select>
        </label>

        <label>
            Item:
            <input id="itemInput" list="itemDatalist" placeholder="Type to search items..." />
            <datalist id="itemDatalist"></datalist>
        </label>

        <label>
            Range:
            <select id="rangeSelect">
                <option value="7">Last 7 days</option>
                <option value="30">Last 30 days</option>
                <option value="180">Last 6 months</option>
                <option value="365">Last year</option>
                <option value="all" selected>All history</option>
            </select>
        </label>

        <img id="itemImage" src="" alt="" />
    </div>

    <canvas id="priceChart" width="900" height="450"></canvas>

    <script>
        const SPREADSHEET_ID = "1_meliJtuKSDwEWRDh1gldcsD-pSjDgIND3dcE1mCjCo";

        // Build CSV URL for a sheet
        function csvUrl(sheet) {
            return `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheet)}`;
        }

        // Robust CSV line parser (handles quoted fields with commas)
        function parseCSVLine(line) {
            const res = [];
            let cur = '';
            let inQ = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') {
                    if (inQ && line[i + 1] === '"') { cur += '"'; i++; }
                    else inQ = !inQ;
                } else if (ch === ',' && !inQ) {
                    res.push(cur);
                    cur = '';
                } else {
                    cur += ch;
                }
            }
            res.push(cur);
            return res.map(s => s.trim().replace(/^"|"$/g, ''));
        }

        // Parse date with multiple fallbacks (ISO, dd/mm/yyyy, serial)
        function parseDateValue(v) {
            if (v == null) return null;
            if (typeof v === 'number' && !isNaN(v)) {
                const serial = v;
                const ms = Math.round(serial * 86400000);
                return new Date(Date.UTC(1899, 11, 30) + ms);
            }
            const s = String(v).trim();
            if (s === '') return null;
            const d1 = new Date(s);
            if (!isNaN(d1.getTime())) return d1;
            const dm = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
            if (dm) {
                let day = parseInt(dm[1], 10);
                let month = parseInt(dm[2], 10);
                let year = parseInt(dm[3], 10);
                if (year < 100) year += 2000;
                return new Date(year, month - 1, day);
            }
            const usMatch = s.match(/^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/);
            if (usMatch) {
                const dd = usMatch[2].padStart(2, '0');
                const iso = `${usMatch[3]}-${("0" + (new Date(Date.parse(usMatch[1] + " 1")).getMonth() + 1)).slice(-2)}-${dd}`;
                const d2 = new Date(iso);
                if (!isNaN(d2.getTime())) return d2;
            }
            const n = Number(s);
            if (!isNaN(n)) {
                const ms = Math.round(n * 86400000);
                return new Date(Date.UTC(1899, 11, 30) + ms);
            }
            return null;
        }

        // Parse price strings robustly (allow currency symbols, comma decimals, thousands)
        function parsePriceValue(v) {
            if (v == null) return null;
            let s = String(v).trim();
            if (s === '') return null;
            s = s.replace(/[^\d\.,-]/g, '');
            if (s === '') return null;
            if (s.indexOf(',') > -1 && s.indexOf('.') === -1) {
                s = s.replace(/,/g, '.');
            } else if (s.indexOf(',') > -1 && s.indexOf('.') > -1) {
                if (s.lastIndexOf('.') > s.lastIndexOf(',')) {
                    s = s.replace(/,/g, '');
                } else {
                    s = s.replace(/\./g, '').replace(/,/g, '.');
                }
            }
            const n = parseFloat(s);
            return isNaN(n) ? null : n;
        }

        // Fetch CSV and parse with the robust helpers; log first parsed rows for debugging
        async function fetchCSV(sheetName) {
            const res = await fetch(csvUrl(sheetName));
            if (!res.ok) {
                console.error('Failed fetching CSV', res.status, res.statusText);
                return [];
            }
            const text = await res.text();
            const lines = text.replace(/\r/g, '').split('\n').filter(l => l.trim() !== '');
            if (lines.length <= 1) return [];

            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = parseCSVLine(lines[i]);
                if (!parts || parts.length < 2) continue;
                const tsRaw = parts[0] ?? '';
                const item = (parts[1] ?? '').trim();
                const priceRaw = parts[2] ?? '';
                if (!item) continue;
                const ts = parseDateValue(tsRaw);
                const price = parsePriceValue(priceRaw);
                // keep original raw timestamp alongside parsed Date so we can show exact time text
                data.push({ ts, tsRaw: tsRaw, item, price });
            }
            console.log(`fetchCSV(${sheetName}) parsed ${data.length} rows. sample:`, data.slice(0, 6));
            return data;
        }

        // Filter data by item and range
        function filterData(data, item, rangeDays) {
            const now = new Date();
            return data.filter(r => {
                if (r.item !== item) return false;
                if (rangeDays !== "all" && r.ts) {
                    const cutoff = new Date(now - rangeDays * 24 * 60 * 60 * 1000);
                    return r.ts >= cutoff;
                }
                return true;
            }).sort((a, b) => {
                if (!a.ts && !b.ts) return 0;
                if (!a.ts) return 1;
                if (!b.ts) return -1;
                return a.ts - b.ts;
            });
        }

        // Update image for selected item
        function updateImage(item) {
            const img = document.getElementById("itemImage");
            img.src = `images/${item}.png`;
            img.alt = item;
        }

        // Draw chart with gaps for missing values and a tooltip attached to the price indicator
        let chart;
        function drawChart(rows, label) {
            // Build label sets
            const tickLabels = rows.map(r => r.ts ? r.ts.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) : "");
            const tooltipDates = rows.map(r => r.ts ? r.ts.toLocaleString() : "");
            const timeTexts = rows.map(r => {
                if (r.tsRaw && String(r.tsRaw).trim() !== '') {
                    const m = String(r.tsRaw).match(/(\d{1,2}:\d{2}(?::\d{2})?)/);
                    if (m) return m[1];
                    if (r.ts) return r.ts.toLocaleTimeString();
                    return String(r.tsRaw);
                }
                return (r.ts ? r.ts.toLocaleTimeString() : '');
            });
            const prices = rows.map(r => (r.price == null || isNaN(r.price)) ? null : r.price);
            const values = prices;

            const ctx = document.getElementById("priceChart").getContext("2d");
            if (chart) chart.destroy();

            // Custom plugin that draws a tooltip box anchored to the hovered data point (attached to the price indicator).
            const attachedTooltipPlugin = {
                id: 'attachedTooltip',
                afterDraw(chartInstance, args, pluginOptions) {
                    // Chart.js keeps an internal array of active elements on hover
                    const active = (chartInstance._active && chartInstance._active.length) ? chartInstance._active[0] : null;
                    if (!active) return;

                    const dsIndex = active.datasetIndex;
                    const idx = active.index;
                    const meta = chartInstance.getDatasetMeta(dsIndex);
                    const point = meta && meta.data ? meta.data[idx] : null;
                    if (!point) return;

                    const chartArea = chartInstance.chartArea;
                    const x = point.x;
                    const y = point.y;
                    const ctx = chartInstance.ctx;

                    // prepare text lines: date, price, time
                    const dateLine = (pluginOptions.dates && pluginOptions.dates[idx]) || '';
                    const priceVal = (pluginOptions.prices && typeof pluginOptions.prices[idx] !== 'undefined') ? pluginOptions.prices[idx] : null;
                    const priceLine = priceVal == null ? 'Price: N/A' : 'Price: ' + Number(priceVal).toLocaleString();
                    const timeLine = (pluginOptions.times && pluginOptions.times[idx]) || '';

                    const lines = [dateLine, priceLine];
                    if (timeLine) lines.push(timeLine);

                    // styling and metrics
                    const font = pluginOptions.font || '12px system-ui';
                    ctx.save();
                    ctx.font = font;
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = pluginOptions.textColor || '#111';

                    const padding = pluginOptions.padding || 6;
                    const lineHeight = (pluginOptions.lineHeight || 16);
                    let maxWidth = 0;
                    for (let i = 0; i < lines.length; i++) {
                        const w = ctx.measureText(lines[i]).width;
                        if (w > maxWidth) maxWidth = w;
                    }
                    const boxW = Math.round(maxWidth + padding * 2);
                    const boxH = Math.round(lines.length * lineHeight + padding * 2);

                    // Determine point radius (fall back to plugin option)
                    const pointRadius = (meta.data && meta.data[idx] && meta.data[idx].options && meta.data[idx].options.radius) ?
                        meta.data[idx].options.radius :
                        (pluginOptions.pointRadius || 5);
                    const gap = pluginOptions.gap || 6;

                    // Prefer to place the box above the point; if there's not enough room put it below.
                    let boxX = x - boxW / 2;
                    let boxY = y - (pointRadius + gap + boxH);

                    // keep inside horizontal bounds
                    if (boxX < chartArea.left + 4) boxX = chartArea.left + 4;
                    if (boxX + boxW > chartArea.right - 4) boxX = chartArea.right - boxW - 4;

                    // if not enough space above, place below
                    if (boxY < chartArea.top + 4) {
                        boxY = y + pointRadius + gap;
                    }

                    // draw connector triangle pointing from box to point
                    ctx.beginPath();
                    ctx.fillStyle = pluginOptions.boxColor || 'rgba(255,255,255,0.98)';
                    ctx.strokeStyle = pluginOptions.boxBorder || 'rgba(0,0,0,0.08)';
                    ctx.lineWidth = pluginOptions.boxBorderWidth || 1;

                    // rounded rect background
                    roundRect(ctx, boxX, boxY, boxW, boxH, pluginOptions.radius || 6);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();

                    // triangle pointer
                    const triW = 10;
                    const triH = 6;
                    // pointer base x (clamped inside box)
                    const pointerX = Math.max(boxX + 8, Math.min(boxX + boxW - 8, x));
                    ctx.beginPath();
                    if (boxY < y) {
                        // box above point -> triangle pointing down
                        ctx.moveTo(pointerX - triW / 2, boxY + boxH);
                        ctx.lineTo(pointerX + triW / 2, boxY + boxH);
                        ctx.lineTo(x, y - pointRadius / 2);
                    } else {
                        // box below point -> triangle pointing up
                        ctx.moveTo(pointerX - triW / 2, boxY);
                        ctx.lineTo(pointerX + triW / 2, boxY);
                        ctx.lineTo(x, y + pointRadius / 2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // draw circle on the data point (price indicator) - slightly larger + border so it visually connects
                    ctx.beginPath();
                    const bubbleR = pluginOptions.bubbleRadius || Math.max(4, pointRadius);
                    ctx.fillStyle = pluginOptions.bubbleColor || '#007bff';
                    ctx.strokeStyle = pluginOptions.bubbleBorder || '#fff';
                    ctx.lineWidth = pluginOptions.bubbleBorderWidth || 2;
                    ctx.arc(x, y, bubbleR, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();

                    // draw text lines inside box
                    ctx.fillStyle = pluginOptions.textColor || '#111';
                    for (let i = 0; i < lines.length; i++) {
                        const tx = boxX + padding;
                        const ty = boxY + padding + i * lineHeight;
                        ctx.fillText(lines[i], tx, ty);
                    }

                    ctx.restore();

                    // helper: rounded rect
                    function roundRect(ctx, x, y, width, height, radius) {
                        if (radius === undefined) radius = 6;
                        const r = Math.min(radius, width / 2, height / 2);
                        ctx.beginPath();
                        ctx.moveTo(x + r, y);
                        ctx.arcTo(x + width, y, x + width, y + height, r);
                        ctx.arcTo(x + width, y + height, x, y + height, r);
                        ctx.arcTo(x, y + height, x, y, r);
                        ctx.arcTo(x, y, x + width, y, r);
                        ctx.closePath();
                    }
                }
            };

            chart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: tickLabels,
                    datasets: [{
                        label,
                        data: values,
                        borderWidth: 2,
                        tension: 0.2,
                        spanGaps: false,
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0,123,255,0.1)',
                        pointRadius: 5,
                        pointHoverRadius: 9,
                        showLine: true
                    }]
                },
                plugins: [attachedTooltipPlugin],
                options: {
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    },
                    scales: {
                        x: {
                            display: true,
                            title: { display: false },
                            ticks: {
                                maxRotation: 0,
                                autoSkip: true,
                                callback: function (value, index, ticks) {
                                    return tickLabels[index] || '';
                                }
                            }
                        },
                        y: { beginAtZero: false }
                    },
                    plugins: {
                        legend: { display: false },
                        // disable built-in tooltip so our attached box is the single source of hover info
                        tooltip: { enabled: false },
                        // configure plugin options (dates/prices/times passed so plugin can render full lines)
                        attachedTooltip: {
                            dates: tooltipDates,
                            times: timeTexts,
                            prices: prices,
                            boxColor: 'rgba(255,255,255,0.98)',
                            boxBorder: 'rgba(0,0,0,0.08)',
                            bubbleColor: '#007bff',
                            bubbleBorder: '#ffffff',
                            bubbleRadius: 6,
                            bubbleBorderWidth: 2,
                            textColor: '#111',
                            font: '12px system-ui',
                            padding: 8,
                            lineHeight: 16,
                            gap: 8,
                            radius: 6
                        }
                    }
                }
            });
        }

        // Fuzzy-ish resolver: exact match, then contains, else first
        function resolveItem(inputValue, items) {
            const v = (inputValue || "").trim();
            if (!items || items.length === 0) return null;
            if (!v) return items[0];
            const lower = v.toLowerCase();
            const exact = items.find(n => n.toLowerCase() === lower);
            if (exact) return exact;
            const contains = items.find(n => n.toLowerCase().includes(lower));
            return contains || items[0];
        }

        function populateItemsDatalist(uniqueItems) {
            const dl = document.getElementById("itemDatalist");
            dl.innerHTML = "";
            uniqueItems.forEach(name => dl.appendChild(new Option(name, name)));
        }

        // Initialize page
        async function init() {
            const typeSel = document.getElementById("typeSelect");
            const itemInput = document.getElementById("itemInput");
            const rangeSel = document.getElementById("rangeSelect");

            itemInput.readOnly = false;
            itemInput.removeAttribute("disabled");

            let allData = await fetchCSV(typeSel.value);
            let uniqueItems = [];

            function rebuildItems() {
                uniqueItems = [...new Set(allData.map(r => r.item))].sort();
                populateItemsDatalist(uniqueItems);
            }

            rebuildItems();

            // refresh: if commit=true we will set the input to resolved value
            async function refresh(commit = false) {
                const sheet = typeSel.value;
                const range = rangeSel.value === "all" ? "all" : Number(rangeSel.value);

                const candidate = resolveItem(itemInput.value, uniqueItems);
                if (!candidate) {
                    if (chart) chart.destroy();
                    return;
                }

                if (commit && itemInput.value !== candidate) {
                    itemInput.value = candidate;
                }

                const filtered = filterData(allData, candidate, range);
                updateImage(candidate);

                // Use the visible label for chart title so label stays correct after we swapped values
                const visibleLabel = typeSel.options[typeSel.selectedIndex].text;
                drawChart(filtered, `${visibleLabel} Price`);
            }

            // Events
            typeSel.addEventListener("change", async () => {
                allData = await fetchCSV(typeSel.value);
                rebuildItems();
                refresh(false);
            });

            itemInput.addEventListener("input", () => refresh(false));
            itemInput.addEventListener("change", () => refresh(true));
            itemInput.addEventListener("blur", () => refresh(true));
            itemInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    refresh(true);
                    itemInput.blur();
                }
            });

            rangeSel.addEventListener("change", () => refresh(false));

            // initial render (preview)
            refresh(false);
        }

        init();
    </script>
</body>
</html>